<!-- -*- mode: agda2; -*- -->
# How to use the Agda JS FFI

```agda
module JsFFi where

open import Agda.Primitive using (Level ; _⊔_)
```

## Builtins

### Booleans

```agda
open import Agda.Builtin.Bool
```

### Lists

```agda
open import Agda.Builtin.List
```

### Strings

```agda
open import Agda.Builtin.String
```

### Nat / Int

Natural numbers and integer are compiled to `BigInt`s. This can give some type coercion issues when
mixing numbers used in Agda and numbers generated by javascript functions. For example, when
the index parameter from the `.map()` function should be manually converted into a `BigInt` when returned or
combined with Agda numbers.

Integers are also compiled to `BigInt`s but pattern matching on them is compiled to a ternary that tests
whether the number is postive (for the `pos` constructor) or negative (for the `negsuc` constructor).

```agda
open import Agda.Builtin.Nat
open import Agda.Builtin.Int

postulate n : Int
{-# COMPILE JS n = BigInt(-20) #-}

postulate _⋯_ : Nat → Nat → List Nat -- Could also replace Nat with Int, and the pragma would stay the same
{-# COMPILE JS _⋯_ = n => k => Array(k - n).fill(null).map((_, i) => BigInt(i) + n) #-}
```

Some builtin Agda modules already have pragma directives that have efficient JS representations. For example,
`Nat`s are compiled to `number`s, `Bool`s to `boolean`s, `IO` is compiled to CPS, etc.

### IO

```agda
open import Agda.Builtin.IO
```

## Regular functions

To define functions defined in JS, you can postulate the function's type and use the COMPILE JS pragma
to define what function should be called instead. This function receives all parameters of the postulated
type, even the implicit ones (which is something to be careful about when using `private variable`s).

```agda
postulate process-api vscode-api Process : Set
postulate child-process : process-api

postulate spawn : process-api → String → List String → Process
{-# COMPILE JS spawn = process => cmd => args => process.spawn(cmd, args) #-}

proc = spawn child-process "agda" ("--interaction-json" ∷ [])
```

It is also allowed to attach a COMPILE JS pragma to functions that have not been postulated. Agda uses the
definition for unfolding definitional equalities, and uses the function from the pragma in the compiled output.
This allows you get the best of both worlds: reasoning capabilities and efficient runtime behaviour.

```agda
_times_ : {A : Set} → Nat → (Nat → A) → List A
zero times f = []
suc n times f = f n ∷ n times f
{-# COMPILE JS _times_ = _ => n => f => Array(n).fill(null).map((_, i) => f(BigInt(i))) #-}

l = 1_000_000 times λ x → x -- Look! No stack overflows
```

Extra parameters can come from implicit variables, either declared in the type or via `variable` blocks, and from module parameters.

```agda
module _ (A : Set) where
    private variable B : Set

    postulate _∘_ : {C : Set} → (B → C) → (A → B) → A → C
    {-# COMPILE JS _∘_ = A => B => C => f => g => x => f(g(x)) #-}
```

## Data types

We can also define the representation of a data type used in the compiled agda code using
pragmas. Firstly, we define the data type in Agda, then we define pragmas for

- each constructor: these are functions that take parameters for each field they contain and
  produce the representation.
- the type: which is used as the pattern matching function. This function receives two arguments:
  the representation and a dictionary that contains entries for each constructor that call the
  corresponding arms of the pattern match. The pattern matching function should be parenthesised since
  agda will inline it when compiling pattern matches.

```agda
data Maybe (A : Set) : Set where
    nothing : Maybe A
    just    : A → Maybe A

{-# COMPILE JS Maybe   = ((x, v) => x === undefined ? v["nothing"]() : v["just"](x)) #-}
{-# COMPILE JS nothing = undefined #-}
{-# COMPILE JS just    = a => a #-}

m₁ m₂ : Maybe Nat
m₁ = just 20
m₂ = nothing
```

## Records 

Records are similar to data types, but you need to additionally define a pragma for every field.
The names of the variables is `<record name>.<field name>` and their only parameter is the constructor
representation. Agda takes care of record updates, it compiles them to a new instance of the record
where the unchanged fields are passed via the field function, and the changed fields are transformed
according to the record update.

```agda
record Σ {ℓ₁ ℓ₂ : Level} (A : Set ℓ₁) (B : A → Set ℓ₂) : Set (ℓ₁ ⊔ ℓ₂) where
    constructor _,_
    field
        proj₁ : A
        proj₂ : B proj₁

{-# COMPILE JS Σ = (([a, b], v) => v["_,_"](a, b)) #-}
{-# COMPILE JS _,_ = a => b => [a, b] #-}
{-# COMPILE JS Σ.proj₁ = ([a, b]) => a #-}
{-# COMPILE JS Σ.proj₂ = ([a, b]) => b #-}

Σ₁ Σ₂ : Σ Nat λ _ → Nat
Σ₁ = 10 , 20
Σ₂ = record Σ₁ { proj₂ = 30 }
```

You can also remove the constructor to make a values of a type only constructable through the ffi. The
representation of this type is then defined by how you define the functions for the fields. The pattern
matching function should still be defined. Whenever no constructor is defined, agda calls the constructor
internally "record", which is the only key in the dictionary given to `v`.

```agda
record System : Set where field
    process : process-api
    vscode  : vscode-api

-- The representation of a System is an object with two properties: "process" and "vscode"
{-# COMPILE JS System = ((x, v) => v["record"](x.process, x.vscode)) #-}
{-# COMPILE JS System.process = ({ process }) => process #-}
{-# COMPILE JS System.vscode  = ({ vscode  }) => vscode #-}
```
